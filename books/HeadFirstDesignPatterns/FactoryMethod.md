# 工厂模式

工厂模式分两种模式：  

1. 工厂方法
2. 抽象工厂


## 简单工厂

使用`new Xxx()`创建对象非常脆弱，缺乏弹性，耦合度高。

![](http://ww1.sinaimg.cn/large/98900c07jw1f5zcr70c9ij206u04d3yi.jpg)  

当具体类需要新增或删除的时候，就必须修改这段代码，非常容易出错，难以维护和更新。  

所以需要把创建对象的方法封装起来，用“工厂”来负责创建对象。  

定义Factory：  
![](http://ww3.sinaimg.cn/large/98900c07jw1f5zd1wwkihj208r062dg5.jpg)

使用：  

![](http://ww4.sinaimg.cn/large/98900c07jw1f5zd2n94izj208o072dgd.jpg)


看起来可能只是把代码挪到了另外一个地方，但是其实有不少好处。  

### 好处
1. 避免代码重复，可复用，也可服务多个对象
2. 降低耦合度，增加弹性
3. 便于维护

NOTE：它跟静态方法的差别是，静态方法不需要实例化，并且它不能通过继承来改变创建方法的行为。  

oh，另外，其实简单工厂并不是设计模式。  

## 工厂方法

工厂方法模式(FactoryMethod)定义了**一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。**    

工厂方法通过**让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的
**，所以工厂方法是 **继承，覆盖方法来实现**  

通常工厂方法模板是这样的：  

```
// 返回对象和入参根据实际情况定  
abstract Product factoryMethod（String type）;
```


![](http://ww3.sinaimg.cn/large/98900c07jw1f5zcaul6vcj20ah076gm3.jpg)

`createPizza`应该是受保护权限

在父类`PizzaStore`中定义`createPizza`抽象方法，让子类去实现。  

NOTE：也可以不是抽象方法，提供默认的实现。

### 好处
1. 将‘实例化’从‘使用’中解耦
2. 易扩展 易维护
3. 更具弹性



## 抽象工厂

抽象工厂模式：**提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。**  


抽象工厂允许**客户使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是什么**。这样一来客户就从具体的产品中被解耦。

抽象工厂跟工厂方法非常相似，但抽象工厂强调的是**一组产品**，是对组的抽象，需要一个大的接口；工厂方法使用的是类与继承而抽象工厂使用的是**组合**；

## 要点

1. 所有的工厂都是用来封装对象的创建。  
2. 工厂方法使用继承：把对象的创建委托给子类，将实例化延迟到子类。  
3. 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。  
4. 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。  
5. 抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。  

## See also

[Factory method pattern
](https://en.wikipedia.org/wiki/Factory_method_pattern)

[Factory Design Pattern Example
](http://javadesign-patterns.blogspot.com/p/factory-desig.html)  
